{"history":[{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"gradient","usesPingPong":false,"speed":0.25,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform vec2 uMousePos;vec3 getColor(int index) { switch(index) { case 0: return vec3(0, 0, 0); case 1: return vec3(0, 0, 0); case 2: return vec3(0, 0, 0); case 3: return vec3(0, 0, 0); case 4: return vec3(0, 0, 0); case 5: return vec3(0, 0, 0); case 6: return vec3(0, 0, 0); case 7: return vec3(0, 0, 0); case 8: return vec3(0, 0, 0); case 9: return vec3(0, 0, 0); case 10: return vec3(0, 0, 0); case 11: return vec3(0, 0, 0); case 12: return vec3(0, 0, 0); case 13: return vec3(0, 0, 0); case 14: return vec3(0, 0, 0); case 15: return vec3(0, 0, 0); default: return vec3(0.0); } }const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) { float s = sin(angle); float c = cos(angle); return vec2( coord.x * c - coord.y * s, coord.x * s + coord.y * c ); }out vec4 fragColor;vec3 getColor(vec2 uv) {return vec3(0, 0, 0); }void main() {vec2 uv = vTextureCoord; vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000); uv -= pos; uv /= (0.5000*2.); uv = rotate(uv, (0.0000 - 0.5) * 2. * PI); vec4 color = vec4(getColor(uv), 1.); fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"],"data":{"downSample":0.5,"depth":false,"uniforms":{},"isBackground":true},"id":"effect"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"wisps","usesPingPong":false,"speed":0.25,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform float uTime; uniform vec2 uMousePos; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return src + dst; }out vec4 fragColor; const float PI = 3.14159265359; mat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }vec2 hash(vec2 p) { p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3))); return -1.0 + 2.0 * fract(sin(p) * 43758.5453123); }float luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }float voronoi_additive(vec2 st, float radius, vec2 mouse_pos, float scale) { vec2 i_st = floor(st); vec2 f_st = fract(st);float wander = 0.0000 * uTime * 0.2; float total_contribution = 0.0;for (int y = -2; y <= 2; y++) { for (int x = -2; x <= 2; x++) { vec2 neighbor = vec2(float(x), float(y)); vec2 cell_id = i_st + neighbor; vec2 point = hash(cell_id); point = 0.5 + 0.5 * sin(5. + wander + 6.2831 * point); vec2 starAbsPos = cell_id + point; vec2 dirToMouse = mouse_pos - starAbsPos; float distToMouse = length(dirToMouse); float attractStrength = 0.0000 * exp(-distToMouse * mix(2.0 + 0.5400 * 2., 0.5, 0.5000)) * 2.; starAbsPos += dirToMouse * attractStrength; vec2 diff = starAbsPos - st; float dist = length(diff);float contribution = radius / max(dist, radius * 0.1); float shimmer_phase = dot(point, vec2(1.0)) * 10. + hash(cell_id).x * 5.0 + uTime * 0.5; float shimmer = mix(1., (sin(shimmer_phase) + 1.), 1.0000); contribution *= shimmer; total_contribution += mix(contribution*contribution, contribution * 2., 0.6000); } }return total_contribution; }vec4 randomStyle() { vec2 uv = vTextureCoord;vec4 bg = texture(uTexture, uv);vec4 color = vec4(0.0); vec2 aspectRatio = vec2(uResolution.x / uResolution.y, 1.0);vec2 mPos = mix(vec2(0.0), (uMousePos - 0.5), 0.0000);uv -= vec2(0.5, 0.5); uv *= aspectRatio; uv = uv * rot(0.3194 * 2.0 * PI); uv *= 40.0 * 0.5400; uv *= mix(vec2(1.0), vec2(1.0, 0.0), 0.9600); uv /= aspectRatio;mPos = mPos * rot(0.3194 * 2.0 * PI);vec2 mouseGrid = uMousePos; mouseGrid -= vec2(0.5, 0.5); mouseGrid *= aspectRatio; mouseGrid = mouseGrid * rot(0.3194 * 2.0 * PI); mouseGrid *= 40.0 * 0.5400; mouseGrid *= mix(vec2(1.0), vec2(1.0, 0.0), 0.9600); mouseGrid /= aspectRatio;vec2 movementOffset = vec2(0.0, uTime * 0.5000 * -0.05); vec2 mouseGrid1 = mouseGrid - (mPos * 38.0 * 0.5400) + movementOffset; vec2 mouseGrid2 = mouseGrid - (mPos * 48.0 * 0.5400) + movementOffset;vec2 st1 = uv - (mPos * 38.0 * 0.5400); vec2 st2 = uv - (mPos * 48.0 * 0.5400);vec2 mouse1 = st1 + vec2(0.0, uTime * 0.5000 * -0.05); vec2 mouse2 = st2 + vec2(0.0, uTime * 0.5000 * -0.05);float radius1 = 0.5 * 0.0900; float radius2 = 0.5 * 0.0900;float pass1 = voronoi_additive(mouse1 * aspectRatio, radius1, mouseGrid1 * aspectRatio, 38.0 * 0.5400); float pass2 = voronoi_additive(mouse2 * aspectRatio + vec2(10), radius2, mouseGrid2 * aspectRatio + vec2(10.0), 48.0 * 0.5400);pass1 *= 0.02; pass2 *= 0.04;color.rgb = (pass1 + pass2) * vec3(1, 1, 1) * mix(1.0, bg.r, 0.0000); color.rgb = clamp(color.rgb, 0.0, 1.0);color.rgb = blend(1, bg.rgb, color.rgb);color = vec4(color.rgb, max(bg.a, luma(color.rgb))); return color; }void main() { vec4 color;color = randomStyle(); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect1"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"twod_sdf","usesPingPong":false,"texture":false,"speed":0.25,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution;out vec4 fragColor;const float PI = 3.14159265359;mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }float sdCircle(vec2 uv, float r) { return length(uv) - r; }float getDistance(vec2 uv) { return sdCircle(uv, 0.4); }float getDist(vec2 uv) { float sd = getDistance(uv);vec2 aspect = vec2(uResolution.x/uResolution.y, 1.0); vec2 mousePos = (uMousePos * aspect); float mouseDistance = length(vTextureCoord * aspect - mousePos); float falloff = smoothstep(0.0, 0.8, mouseDistance); float asd = 2.0;asd = -asd;float md = mix(0.02/falloff, 0.1/falloff, -asd * sd); md = md * 1.5 * 0.0000; md = min(-md, 0.0); sd -= md;return sd; }vec4 refrakt(float sd, vec2 st, vec4 bg) {sd = -sd;vec2 offset = mix(vec2(0), normalize(st)/sd, length(st));vec4 r = vec4(0,0,0,1); float rdisp = mix(0.01, 0.008, 0.5000); float gdisp = mix(0.01, 0.01, 0.5000); float bdisp = mix(0.01, 0.012, 0.5000); vec2 uv = (vTextureCoord - 0.5) / mix(1., 4., 0.0000) + 0.5; r.r = texture(uTexture, uv + offset * (0.7500 - 0.5) * rdisp).r; r.g = texture(uTexture, uv + offset * (0.7500 - 0.5) * gdisp).g; r.b = texture(uTexture, uv + offset * (0.7500 - 0.5) * bdisp).b; float opacity = ceil(-sd); float smoothness = 0.0025; opacity = smoothstep(0., smoothness, -sd);vec4 background = bg; return mix(background, r + vec4(vec3(0.615686274509804, 0.615686274509804, 0.615686274509804)/(-sd * 50.), 1.) * 4.6000, opacity); }vec4 getEffect(vec2 st, vec4 bg) { float eps = 0.0005;float sd = getDist(st); float sd1 = getDist(st + vec2(eps, 0.0)); float sd2 = getDist(st - vec2(eps, 0.0)); float sd3 = getDist(st + vec2(0.0, eps)); float sd4 = getDist(st - vec2(0.0, eps));vec4 r = refrakt(sd, st, bg); vec4 r1 = refrakt(sd1, st + vec2(eps, 0.0), bg); vec4 r2 = refrakt(sd2, st - vec2(eps, 0.0), bg); vec4 r3 = refrakt(sd3, st + vec2(0.0, eps), bg); vec4 r4 = refrakt(sd4, st - vec2(0.0, eps), bg); r = (r + r1 + r2 + r3 + r4) * 0.2; return r; } void main() { vec2 uv = vTextureCoord; vec4 bg = texture(uTexture, uv); vec4 color = vec4(1); vec2 aspect = vec2(uResolution.x/uResolution.y, 1.0); vec2 mousePos = mix(vec2(0), uMousePos - 0.5, 0.0000); vec2 st = uv - (vec2(0.49130434782608695, 0.9900434782608696) + mousePos); st *= aspect; st *= 1./(0.2700 + 0.2); st *= rot(0.0054 * 2.0 * PI); color = getEffect(st, bg); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect2"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"beam","usesPingPong":false,"speed":0.25,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float; precision highp int;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return 1. - (1. - src) * (1. - dst); }uvec2 pcg2d(uvec2 v) { v = v * 1664525u + 1013904223u; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; v ^= v >> 16; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; return v; }float randFibo(vec2 p) { uvec2 v = floatBitsToUint(p); v = pcg2d(v); uint r = v.x ^ v.y; return float(r) / float(0xffffffffu); }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }out vec4 fragColor;const float PI = 3.14159265359; const float TWO_PI = 2.0 * PI;float calculateAngle(vec2 point, vec2 center) { vec2 direction = point - center; float angle = atan(direction.y, direction.x); if (angle < 0.0) { angle += TWO_PI; } return angle; }float luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }float angularDifference(float angle1, float angle2) { float diff = abs(angle1 - angle2); if (diff > PI) { diff = TWO_PI - diff; } return diff; }float angularFading(float pointAngle, float peakAngle, float fadeAmount) { float diff = angularDifference(pointAngle, peakAngle); return 1.04 - smoothstep(0.0, fadeAmount, diff); }mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }vec3 drawRing(vec2 uv, vec2 center, float scale, float angle) { uv.x *= uResolution.x/uResolution.y; center.x *= uResolution.x/uResolution.y; vec2 skew = vec2(0.5000, 1. - 0.5000) * 2.; uv = uv * rot(0.0000 * TWO_PI) * skew; center = center * rot(0.0000 * TWO_PI) * skew; float ringRadius = scale * 0.5; float distFromCenter = length(uv - center); float ringDist = abs(distFromCenter - ringRadius); float lineRadius = 0.1000 * 0.25; float brightness = lineRadius / (1.0 - smoothstep(0.2, 0.002, ringDist + 0.02));angle = fract(0.0000 + uTime * 0.01 + 0.4900) * TWO_PI;float pointAngle = calculateAngle(uv, center); float peakAngle = angle; float angleFactor = angularFading(pointAngle, peakAngle, PI * 0.5);brightness *= angleFactor;vec3 ringColor = brightness * pow(1. - ringDist, 3.) * vec3(0.9333333333333333, 0.9333333333333333, 0.9333333333333333); return ringColor; }vec3 getBeam(vec2 uv) { vec2 pos = vec2(0.5, 0.97) + mix(vec2(0), (uMousePos-0.5), 0.0000); return drawRing(uv, pos, 0.7600, 0.0000); }void main() { vec2 uv = vTextureCoord; vec4 bg = texture(uTexture, uv);vec3 beam = getBeam(uv); float dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;vec3 blended = blend(4, Tonemap_tanh(beam), bg.rgb); vec3 result = mix(bg.rgb, blended, 0.5300); result += dither;vec4 color = vec4(result, max(bg.a, luma(beam))); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect3"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"stretch","usesPingPong":false,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t == 0.0 ? 0.0 : t == 1.0 ? 1.0 : t < 0.5 ? pow(2.0, (20.0 * t) - 10.0) / 2.0 : (2.0 - pow(2.0, -20.0 * t + 10.0)) / 2.0; }out vec4 fragColor;vec2 rotate(vec2 v, float angle) { float c = cos(angle); float s = sin(angle); return vec2(v.x * c - v.y * s, v.x * s + v.y * c); }vec3 chromatic_aberration(vec3 color, vec2 uv, float amount) { vec2 offset = normalize(vTextureCoord - 0.5) * amount / vec2(uResolution.x/uResolution.y, 1); vec4 left = texture(uTexture, uv - offset); vec4 right = texture(uTexture, uv + offset);color.r = left.r; color.b = right.b;return color; }void main() { vec2 uv = vTextureCoord; float angle = (0.9990 - 0.25) * -6.28318530718; float stretchX = vec2(1.41, 20).x * 4. * 1.8400; float stretchY = vec2(1.41, 20).y * 4. * 1.8400;vec2 pos = vec2(0.5, 0.48) + (uMousePos - 0.5) * 0.0000; vec2 offset = uv - pos; vec2 rotatedOffset = rotate(offset, -angle); vec2 stretchedOffset = rotatedOffset; if (1 == 1) { if (rotatedOffset.x > 0.0) { float stretchIntensity = rotatedOffset.x; float easedIntensity = ease(18, stretchIntensity); stretchedOffset.x = rotatedOffset.x / (1.0 + stretchX * easedIntensity); stretchedOffset.y = rotatedOffset.y / (1.0 + stretchY * easedIntensity * easedIntensity); } } else if (1 == 2) { float stretchIntensity = abs(rotatedOffset.x); float easedIntensity = ease(18, stretchIntensity); stretchedOffset.x = sign(rotatedOffset.x) * stretchIntensity / (1.0 + stretchX * easedIntensity); stretchedOffset.y = rotatedOffset.y / (1.0 + stretchY * easedIntensity * easedIntensity); } vec2 finalOffset = rotate(stretchedOffset, angle); vec2 st = pos + finalOffset; vec4 color = texture(uTexture, st);color.rgb = chromatic_aberration(color.rgb, st, length(st - uv) * 0.05 * 0.0000); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect4"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"gradientMap","usesPingPong":false,"speed":0.5,"texture":false,"animating":false,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;vec3 getColor(int index) { switch(index) { case 0: return vec3(0, 0, 0); case 1: return vec3(0.25098039215686274, 0.11372549019607843, 0.7490196078431373); case 2: return vec3(0.5176470588235295, 0, 1); case 3: return vec3(0.9137254901960784, 0.47058823529411764, 1); case 4: return vec3(1, 1, 1); case 5: return vec3(0, 0, 0); case 6: return vec3(0, 0, 0); case 7: return vec3(0, 0, 0); case 8: return vec3(0, 0, 0); case 9: return vec3(0, 0, 0); case 10: return vec3(0, 0, 0); case 11: return vec3(0, 0, 0); case 12: return vec3(0, 0, 0); case 13: return vec3(0, 0, 0); case 14: return vec3(0, 0, 0); case 15: return vec3(0, 0, 0); default: return vec3(0.0); } }float getStop(int index) { switch(index) { case 0: return 0.0000; case 1: return 0.2719; case 2: return 0.5781; case 3: return 0.8031; case 4: return 1.0000; case 5: return 0.0000; case 6: return 0.0000; case 7: return 0.0000; case 8: return 0.0000; case 9: return 0.0000; case 10: return 0.0000; case 11: return 0.0000; case 12: return 0.0000; case 13: return 0.0000; case 14: return 0.0000; case 15: return 0.0000; default: return 0.0; } }float luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }float rand(vec2 co) { return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453); }vec3 linear_from_srgb(vec3 rgb) { return pow(rgb, vec3(2.2)); }vec3 srgb_from_linear(vec3 lin) { return pow(lin, vec3(1.0/2.2)); }vec3 oklab_mix(vec3 lin1, vec3 lin2, float a) { const mat3 kCONEtoLMS = mat3( 0.4121656120, 0.2118591070, 0.0883097947, 0.5362752080, 0.6807189584, 0.2818474174, 0.0514575653, 0.1074065790, 0.6302613616); const mat3 kLMStoCONE = mat3( 4.0767245293, -1.2681437731, -0.0041119885, -3.3072168827, 2.6093323231, -0.7034763098, 0.2307590544, -0.3411344290, 1.7068625689); vec3 lms1 = pow( kCONEtoLMS*lin1, vec3(1.0/3.0) ); vec3 lms2 = pow( kCONEtoLMS*lin2, vec3(1.0/3.0) ); vec3 lms = mix( lms1, lms2, a ); lms *= 1.0 + 0.02 * a * (1.0 - a); return kLMStoCONE*(lms*lms*lms); }vec3 getGradientColor(float position) { position = clamp(position, 0.0, 1.0); for (int i = 0; i < 5 - 1; i++) { float colorPosition = getStop(i); float nextColorPosition = getStop(i + 1); if (position <= nextColorPosition) { float mixFactor = (position - colorPosition) / (nextColorPosition - colorPosition); vec3 linStart = linear_from_srgb(getColor(i)); vec3 linEnd = linear_from_srgb(getColor(i + 1)); vec3 mixedLin = oklab_mix(linStart, linEnd, clamp(mixFactor, 0.0, 1.0)); return srgb_from_linear(mixedLin); } } return getColor(5 - 1); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); float position = smoothstep(0., 1., luma(color.rgb)) * (0.4600 * 2.); float posOffset = (dot(vec2(0.5200348432055749, 0.5543554006968641).x, vec2(0.5200348432055749, 0.5543554006968641).y) + 0.2100 + 0.0001) * 2.; position -= (uTime*0.01 + posOffset); float cycle = floor(position); bool reverse = 0.0000 > 0.5 && int(cycle) % 2 == 0; float animatedPos = reverse ? fract(-position) : fract(position); animatedPos = reverse ? fract(-position) : fract(position); animatedPos = clamp(animatedPos, 0.0, 1.0);vec3 gradientColor = getGradientColor(animatedPos); float dither = rand(gl_FragCoord.xy) * 0.005; gradientColor += dither; vec3 mixedColor = mix(color.rgb, gradientColor, 1.0000);color.rgb = mixedColor; fragColor = color; ; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect5"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"fog","usesPingPong":false,"speed":0.5,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uTime; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; } float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }out vec4 fragColor;const int kernelSize = 36; mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }const float PHI = 1.618033988; const float PI = 3.14159265359;float dot_noise(vec3 p) { const mat3 GOLD = mat3( -0.571464913, +0.814921382, +0.096597072, -0.278044873, -0.303026659, +0.911518454, +0.772087367, +0.494042493, +0.399753815); return dot(cos(GOLD * p), sin(PHI * p * GOLD)); }float cheap_fbm(vec3 p) { mat2 rota = mat2(0.6, -0.8, 0.8, 0.6); float nos = 0.; float amp = 1. + 0.3300 * 10.; float xp = sqrt(2.); float halfxp = xp * 0.5; for(int i = 0; i < 6; i++) { float theta = uTime * 0.05 + float(i); p.xy *= xp; p.xy += sin(rota * p.xy * xp + theta) * 0.2; float nz = dot_noise(vec3(p.xy * rota, p.z + theta)); nos += nz * amp * rota[0][0]; amp *= halfxp; rota *= mat2(0.6, -0.8, 0.8, 0.6); } nos *= 1./float(6); float density = -3. + 1.0000 * 6.; return smoothstep(-3., 3., nos + density); }float fnoise(vec2 uv) { float aspectRatio = uResolution.x/uResolution.y; vec2 aspect = vec2(aspectRatio, 1); float multiplier = 10.0 * (0.5000 / ((aspectRatio + 1.) / 2.)); vec2 st = ((uv * aspect - vec2(0.49782608695652175, 0.797) * aspect)) * multiplier * rot((0.0000 - 0.125) * 2. * PI);vec2 mPos = vec2(0.49782608695652175, 0.797) + mix(vec2(0), (uMousePos-0.5), 0.0000); vec2 pos = mix(vec2(0.49782608695652175, 0.797), mPos, floor(0.8000)); float dist = ease(0, max(0.,1.-distance(uv * aspect, mPos * aspect) * 4. * (1. - 0.8000)));if (0 == 1) { dist = max(0., (0.5 - dist)); } float time = uTime * 0.05; vec2 drift = vec2(time * 0.2) * 2.0 * 0.5000; float fbm = cheap_fbm(vec3(st - drift, time)) * dist; fbm = fbm / (1. + fbm); return fbm; }vec4 ExponentialBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); float total_weight = 0.0;float fogNoise = fnoise(uv); float radius = 8.0 * fogNoise * max(0.5700, 0.1); radius = mix(0.01, 0.03, radius);vec2 dir = normalize(direction) / vec2(uResolution.x/uResolution.y, 1);vec4 center = texture(tex, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight;for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = radius * float(i) / 8.0; vec4 sample1 = texture(tex, uv + offset * dir); vec4 sample2 = texture(tex, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; } float scatter = radius * 2.; color += ( texture(tex, uv + scatter * dir) + texture(tex, uv - scatter * dir) ) * 0.0694877157;return color / total_weight; }vec4 blur(vec2 uv, vec2 direction) { return ExponentialBlur(uTexture, uv, direction); }vec4 getColor(vec2 uv) { return blur(uv, vec2(1, 0)); }void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}","#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uTime; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; } float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }out vec4 fragColor;const int kernelSize = 36; mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }const float PHI = 1.618033988; const float PI = 3.14159265359;float dot_noise(vec3 p) { const mat3 GOLD = mat3( -0.571464913, +0.814921382, +0.096597072, -0.278044873, -0.303026659, +0.911518454, +0.772087367, +0.494042493, +0.399753815); return dot(cos(GOLD * p), sin(PHI * p * GOLD)); }float cheap_fbm(vec3 p) { mat2 rota = mat2(0.6, -0.8, 0.8, 0.6); float nos = 0.; float amp = 1. + 0.3300 * 10.; float xp = sqrt(2.); float halfxp = xp * 0.5; for(int i = 0; i < 6; i++) { float theta = uTime * 0.05 + float(i); p.xy *= xp; p.xy += sin(rota * p.xy * xp + theta) * 0.2; float nz = dot_noise(vec3(p.xy * rota, p.z + theta)); nos += nz * amp * rota[0][0]; amp *= halfxp; rota *= mat2(0.6, -0.8, 0.8, 0.6); } nos *= 1./float(6); float density = -3. + 1.0000 * 6.; return smoothstep(-3., 3., nos + density); }float fnoise(vec2 uv) { float aspectRatio = uResolution.x/uResolution.y; vec2 aspect = vec2(aspectRatio, 1); float multiplier = 10.0 * (0.5000 / ((aspectRatio + 1.) / 2.)); vec2 st = ((uv * aspect - vec2(0.49782608695652175, 0.797) * aspect)) * multiplier * rot((0.0000 - 0.125) * 2. * PI);vec2 mPos = vec2(0.49782608695652175, 0.797) + mix(vec2(0), (uMousePos-0.5), 0.0000); vec2 pos = mix(vec2(0.49782608695652175, 0.797), mPos, floor(0.8000)); float dist = ease(0, max(0.,1.-distance(uv * aspect, mPos * aspect) * 4. * (1. - 0.8000)));if (0 == 1) { dist = max(0., (0.5 - dist)); } float time = uTime * 0.05; vec2 drift = vec2(time * 0.2) * 2.0 * 0.5000; float fbm = cheap_fbm(vec3(st - drift, time)) * dist; fbm = fbm / (1. + fbm); return fbm; }vec4 ExponentialBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); float total_weight = 0.0;float fogNoise = fnoise(uv); float radius = 8.0 * fogNoise * max(0.5700, 0.1); radius = mix(0.01, 0.03, radius);vec2 dir = normalize(direction) / vec2(uResolution.x/uResolution.y, 1);vec4 center = texture(tex, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight;for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = radius * float(i) / 8.0; vec4 sample1 = texture(tex, uv + offset * dir); vec4 sample2 = texture(tex, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; } float scatter = radius * 2.; color += ( texture(tex, uv + scatter * dir) + texture(tex, uv - scatter * dir) ) * 0.0694877157;return color / total_weight; }vec4 blur(vec2 uv, vec2 direction) { return ExponentialBlur(uTexture, uv, direction); }vec4 getColor(vec2 uv) { return blur(uv, vec2(0, 1)); }void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}","#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uTime; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; } float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }out vec4 fragColor;const int kernelSize = 36; mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }const float PHI = 1.618033988; const float PI = 3.14159265359;float dot_noise(vec3 p) { const mat3 GOLD = mat3( -0.571464913, +0.814921382, +0.096597072, -0.278044873, -0.303026659, +0.911518454, +0.772087367, +0.494042493, +0.399753815); return dot(cos(GOLD * p), sin(PHI * p * GOLD)); }float cheap_fbm(vec3 p) { mat2 rota = mat2(0.6, -0.8, 0.8, 0.6); float nos = 0.; float amp = 1. + 0.3300 * 10.; float xp = sqrt(2.); float halfxp = xp * 0.5; for(int i = 0; i < 6; i++) { float theta = uTime * 0.05 + float(i); p.xy *= xp; p.xy += sin(rota * p.xy * xp + theta) * 0.2; float nz = dot_noise(vec3(p.xy * rota, p.z + theta)); nos += nz * amp * rota[0][0]; amp *= halfxp; rota *= mat2(0.6, -0.8, 0.8, 0.6); } nos *= 1./float(6); float density = -3. + 1.0000 * 6.; return smoothstep(-3., 3., nos + density); }float fnoise(vec2 uv) { float aspectRatio = uResolution.x/uResolution.y; vec2 aspect = vec2(aspectRatio, 1); float multiplier = 10.0 * (0.5000 / ((aspectRatio + 1.) / 2.)); vec2 st = ((uv * aspect - vec2(0.49782608695652175, 0.797) * aspect)) * multiplier * rot((0.0000 - 0.125) * 2. * PI);vec2 mPos = vec2(0.49782608695652175, 0.797) + mix(vec2(0), (uMousePos-0.5), 0.0000); vec2 pos = mix(vec2(0.49782608695652175, 0.797), mPos, floor(0.8000)); float dist = ease(0, max(0.,1.-distance(uv * aspect, mPos * aspect) * 4. * (1. - 0.8000)));if (0 == 1) { dist = max(0., (0.5 - dist)); } float time = uTime * 0.05; vec2 drift = vec2(time * 0.2) * 2.0 * 0.5000; float fbm = cheap_fbm(vec3(st - drift, time)) * dist; fbm = fbm / (1. + fbm); return fbm; }vec4 ExponentialBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); float total_weight = 0.0;float fogNoise = fnoise(uv); float radius = 8.0 * fogNoise * max(0.5700, 0.1); radius = mix(0.01, 0.03, radius);vec2 dir = normalize(direction) / vec2(uResolution.x/uResolution.y, 1);vec4 center = texture(tex, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight;for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = radius * float(i) / 8.0; vec4 sample1 = texture(tex, uv + offset * dir); vec4 sample2 = texture(tex, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; } float scatter = radius * 2.; color += ( texture(tex, uv + scatter * dir) + texture(tex, uv - scatter * dir) ) * 0.0694877157;return color / total_weight; }vec4 blur(vec2 uv, vec2 direction) { return ExponentialBlur(uTexture, uv, direction); }vec4 getColor(vec2 uv) { return blur(uv, vec2(1, 1)); }void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}","#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uTime; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; } float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }out vec4 fragColor;const int kernelSize = 36; mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }const float PHI = 1.618033988; const float PI = 3.14159265359;float dot_noise(vec3 p) { const mat3 GOLD = mat3( -0.571464913, +0.814921382, +0.096597072, -0.278044873, -0.303026659, +0.911518454, +0.772087367, +0.494042493, +0.399753815); return dot(cos(GOLD * p), sin(PHI * p * GOLD)); }float cheap_fbm(vec3 p) { mat2 rota = mat2(0.6, -0.8, 0.8, 0.6); float nos = 0.; float amp = 1. + 0.3300 * 10.; float xp = sqrt(2.); float halfxp = xp * 0.5; for(int i = 0; i < 6; i++) { float theta = uTime * 0.05 + float(i); p.xy *= xp; p.xy += sin(rota * p.xy * xp + theta) * 0.2; float nz = dot_noise(vec3(p.xy * rota, p.z + theta)); nos += nz * amp * rota[0][0]; amp *= halfxp; rota *= mat2(0.6, -0.8, 0.8, 0.6); } nos *= 1./float(6); float density = -3. + 1.0000 * 6.; return smoothstep(-3., 3., nos + density); }float fnoise(vec2 uv) { float aspectRatio = uResolution.x/uResolution.y; vec2 aspect = vec2(aspectRatio, 1); float multiplier = 10.0 * (0.5000 / ((aspectRatio + 1.) / 2.)); vec2 st = ((uv * aspect - vec2(0.49782608695652175, 0.797) * aspect)) * multiplier * rot((0.0000 - 0.125) * 2. * PI);vec2 mPos = vec2(0.49782608695652175, 0.797) + mix(vec2(0), (uMousePos-0.5), 0.0000); vec2 pos = mix(vec2(0.49782608695652175, 0.797), mPos, floor(0.8000)); float dist = ease(0, max(0.,1.-distance(uv * aspect, mPos * aspect) * 4. * (1. - 0.8000)));if (0 == 1) { dist = max(0., (0.5 - dist)); } float time = uTime * 0.05; vec2 drift = vec2(time * 0.2) * 2.0 * 0.5000; float fbm = cheap_fbm(vec3(st - drift, time)) * dist; fbm = fbm / (1. + fbm); return fbm; }vec4 ExponentialBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); float total_weight = 0.0;float fogNoise = fnoise(uv); float radius = 8.0 * fogNoise * max(0.5700, 0.1); radius = mix(0.01, 0.03, radius);vec2 dir = normalize(direction) / vec2(uResolution.x/uResolution.y, 1);vec4 center = texture(tex, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight;for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = radius * float(i) / 8.0; vec4 sample1 = texture(tex, uv + offset * dir); vec4 sample2 = texture(tex, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; } float scatter = radius * 2.; color += ( texture(tex, uv + scatter * dir) + texture(tex, uv - scatter * dir) ) * 0.0694877157;return color / total_weight; }vec4 blur(vec2 uv, vec2 direction) { return ExponentialBlur(uTexture, uv, direction); }vec4 getColor(vec2 uv) { return blur(uv, vec2(1, -1)); }void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}","#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture; uniform float uTime; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; } uvec2 pcg2d(uvec2 v) { v = v * 1664525u + 1013904223u; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; v ^= v >> 16; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; return v; }float randFibo(vec2 p) { uvec2 v = floatBitsToUint(p); v = pcg2d(v); uint r = v.x ^ v.y; return float(r) / float(0xffffffffu); }vec3 blend (int blendMode, vec3 src, vec3 dst) { return 1. - (1. - src) * (1. - dst); }out vec4 fragColor;const int kernelSize = 36; mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }vec3 Tonemap_ACES(vec3 x) { const float a = 2.51; const float b = 0.03; const float c = 2.43; const float d = 0.59; const float e = 0.14; return (x * (a * x + b)) / (x * (c * x + d) + e); }vec3 chromatic_aberration(vec3 color, vec2 uv, float amount) { vec2 offset = normalize(vTextureCoord - 0.5) * amount / vec2(uResolution.x/uResolution.y, 1); vec4 left = texture(uTexture, uv - offset); vec4 right = texture(uTexture, uv + offset);color.r = left.r; color.b = right.b;return color; }const float PHI = 1.618033988; const float PI = 3.14159265359;float dot_noise(vec3 p) { const mat3 GOLD = mat3( -0.571464913, +0.814921382, +0.096597072, -0.278044873, -0.303026659, +0.911518454, +0.772087367, +0.494042493, +0.399753815); return dot(cos(GOLD * p), sin(PHI * p * GOLD)); }float cheap_fbm(vec3 p) { mat2 rota = mat2(0.6, -0.8, 0.8, 0.6); float nos = 0.; float amp = 1. + 0.3300 * 10.; float xp = sqrt(2.); float halfxp = xp * 0.5; for(int i = 0; i < 6; i++) { float theta = uTime * 0.05 + float(i); p.xy *= xp; p.xy += sin(rota * p.xy * xp + theta) * 0.2; float nz = dot_noise(vec3(p.xy * rota, p.z + theta)); nos += nz * amp * rota[0][0]; amp *= halfxp; rota *= mat2(0.6, -0.8, 0.8, 0.6); } nos *= 1./float(6); float density = -3. + 1.0000 * 6.; return smoothstep(-3., 3., nos + density); }float fnoise(vec2 uv) { float aspectRatio = uResolution.x/uResolution.y; vec2 aspect = vec2(aspectRatio, 1); float multiplier = 10.0 * (0.5000 / ((aspectRatio + 1.) / 2.)); vec2 st = ((uv * aspect - vec2(0.49782608695652175, 0.797) * aspect)) * multiplier * rot((0.0000 - 0.125) * 2. * PI);vec2 mPos = vec2(0.49782608695652175, 0.797) + mix(vec2(0), (uMousePos-0.5), 0.0000); vec2 pos = mix(vec2(0.49782608695652175, 0.797), mPos, floor(0.8000)); float dist = ease(0, max(0.,1.-distance(uv * aspect, mPos * aspect) * 4. * (1. - 0.8000)));if (0 == 1) { dist = max(0., (0.5 - dist)); } float time = uTime * 0.05; vec2 drift = vec2(time * 0.2) * 2.0 * 0.5000; float fbm = cheap_fbm(vec3(st - drift, time)) * dist; fbm = fbm / (1. + fbm); return fbm; }vec4 fogComposite(vec2 uv) { vec4 bg = texture(uBgTexture, uv); vec4 blur = texture(uTexture, uv); float aspectRatio = uResolution.x/uResolution.y; float fogNoise = fnoise(uv); float fogMask = clamp(fogNoise * 2., 0., 1.);vec3 grain = vec3(randFibo(uv + fogNoise));blur.rgb = chromatic_aberration(blur.rgb, uv, fogMask * 0.01 * 0.5700 * (0.7900 * 2.5)); blur.rgb = Tonemap_ACES(blur.rgb * (0.5800 + 0.5)) + grain * 0.05; vec4 foggedBlur = vec4(blur.rgb * vec3(0.8666666666666667, 0.8274509803921568, 1), blur.a); foggedBlur.rgb += (0.0000 * 0.25 * fogMask * vec3(0.8666666666666667, 0.8274509803921568, 1)); foggedBlur.rgb = blend(4, bg.rgb, foggedBlur.rgb * fogMask); return foggedBlur; }vec4 getColor(vec2 uv) { return fogComposite(uv); }void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"downSample":0.25,"depth":false,"uniforms":{},"isBackground":false,"passes":[{"prop":"pass","value":1,"downSample":0.25},{"prop":"pass","value":2,"downSample":0.25},{"prop":"pass","value":3,"downSample":0.25},{"prop":"pass","value":4,"includeBg":true}]},"id":"effect6"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"progressiveBlur","usesPingPong":false,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution; uvec2 pcg2d(uvec2 v) { v = v * 1664525u + 1013904223u; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; v ^= v >> 16; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; return v; }float randFibo(vec2 p) { uvec2 v = floatBitsToUint(p); v = pcg2d(v); uint r = v.x ^ v.y; return float(r) / float(0xffffffffu); }out vec4 fragColor;const float PI = 3.141592;mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }float easeInOutQuad(float t) { return t < 0.5 ? 2.0 * t * t : -1.0 + (4.0 - 2.0 * t) * t; }const int kernelSize = 36; float getGaussianWeight(int index) { switch(index) { case 0: return 0.00094768; case 1: return 0.00151965; case 2: return 0.00237008; case 3: return 0.00359517; case 4: return 0.0053041; case 5: return 0.00761097; case 6: return 0.01062197; case 7: return 0.01441804; case 8: return 0.01903459; case 9: return 0.0244409; case 10: return 0.03052299; case 11: return 0.03707432; case 12: return 0.04379813; case 13: return 0.05032389; case 14: return 0.05623791; case 15: return 0.06112521; case 16: return 0.06461716; case 17: return 0.06643724; case 18: return 0.06643724; case 19: return 0.06461716; case 20: return 0.06112521; case 21: return 0.05623791; case 22: return 0.05032389; case 23: return 0.04379813; case 24: return 0.03707432; case 25: return 0.03052299; case 26: return 0.0244409; case 27: return 0.01903459; case 28: return 0.01441804; case 29: return 0.01062197; case 30: return 0.00761097; case 31: return 0.0053041; case 32: return 0.00359517; case 33: return 0.00237008; case 34: return 0.00151965; case 35: return 0.00094768; default: return 0.0; } }vec4 directionalBlur(vec2 uv, bool isVertical) { vec4 color = vec4(0.0); vec2 pos = vec2(0.48586956521739133, 0.5295652173913044) + mix(vec2(0), (uMousePos-0.5), 0.0000);vec2 st = uv * rot(0.5000 * 2. * PI); pos *= rot(0.5000 * 2. * PI);float dist = easeInOutQuad(pos.y - st.y); float jawn = st.y < pos.y ? 1. : 0.;float amount = 0.9100 * 6. * dist * jawn;if (amount < 0.0001) { return texture(uTexture, uv); } color += texture(uTexture, uv) * 0.00094768;vec2 direction = isVertical ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0); for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; vec2 offset = vec2(x * 0.001) * direction; color += texture(uTexture, uv + offset) * getGaussianWeight(i); }float dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0; color.rgb += dither;return color; }vec4 getColor(vec2 uv) { return directionalBlur(uv, false); }void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}","#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution; uvec2 pcg2d(uvec2 v) { v = v * 1664525u + 1013904223u; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; v ^= v >> 16; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; return v; }float randFibo(vec2 p) { uvec2 v = floatBitsToUint(p); v = pcg2d(v); uint r = v.x ^ v.y; return float(r) / float(0xffffffffu); }out vec4 fragColor;const float PI = 3.141592;mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }float easeInOutQuad(float t) { return t < 0.5 ? 2.0 * t * t : -1.0 + (4.0 - 2.0 * t) * t; }const int kernelSize = 36; float getGaussianWeight(int index) { switch(index) { case 0: return 0.00094768; case 1: return 0.00151965; case 2: return 0.00237008; case 3: return 0.00359517; case 4: return 0.0053041; case 5: return 0.00761097; case 6: return 0.01062197; case 7: return 0.01441804; case 8: return 0.01903459; case 9: return 0.0244409; case 10: return 0.03052299; case 11: return 0.03707432; case 12: return 0.04379813; case 13: return 0.05032389; case 14: return 0.05623791; case 15: return 0.06112521; case 16: return 0.06461716; case 17: return 0.06643724; case 18: return 0.06643724; case 19: return 0.06461716; case 20: return 0.06112521; case 21: return 0.05623791; case 22: return 0.05032389; case 23: return 0.04379813; case 24: return 0.03707432; case 25: return 0.03052299; case 26: return 0.0244409; case 27: return 0.01903459; case 28: return 0.01441804; case 29: return 0.01062197; case 30: return 0.00761097; case 31: return 0.0053041; case 32: return 0.00359517; case 33: return 0.00237008; case 34: return 0.00151965; case 35: return 0.00094768; default: return 0.0; } }vec4 directionalBlur(vec2 uv, bool isVertical) { vec4 color = vec4(0.0); vec2 pos = vec2(0.48586956521739133, 0.5295652173913044) + mix(vec2(0), (uMousePos-0.5), 0.0000);vec2 st = uv * rot(0.5000 * 2. * PI); pos *= rot(0.5000 * 2. * PI);float dist = easeInOutQuad(pos.y - st.y); float jawn = st.y < pos.y ? 1. : 0.;float amount = 0.9100 * 6. * dist * jawn;if (amount < 0.0001) { return texture(uTexture, uv); } color += texture(uTexture, uv) * 0.00094768;vec2 direction = isVertical ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0); for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; vec2 offset = vec2(x * 0.001) * direction; color += texture(uTexture, uv + offset) * getGaussianWeight(i); }float dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0; color.rgb += dither;return color; }vec4 getColor(vec2 uv) { return directionalBlur(uv, false); }void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}","#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution; uvec2 pcg2d(uvec2 v) { v = v * 1664525u + 1013904223u; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; v ^= v >> 16; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; return v; }float randFibo(vec2 p) { uvec2 v = floatBitsToUint(p); v = pcg2d(v); uint r = v.x ^ v.y; return float(r) / float(0xffffffffu); }out vec4 fragColor;const float PI = 3.141592;mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }float easeInOutQuad(float t) { return t < 0.5 ? 2.0 * t * t : -1.0 + (4.0 - 2.0 * t) * t; }const int kernelSize = 36; float getGaussianWeight(int index) { switch(index) { case 0: return 0.00094768; case 1: return 0.00151965; case 2: return 0.00237008; case 3: return 0.00359517; case 4: return 0.0053041; case 5: return 0.00761097; case 6: return 0.01062197; case 7: return 0.01441804; case 8: return 0.01903459; case 9: return 0.0244409; case 10: return 0.03052299; case 11: return 0.03707432; case 12: return 0.04379813; case 13: return 0.05032389; case 14: return 0.05623791; case 15: return 0.06112521; case 16: return 0.06461716; case 17: return 0.06643724; case 18: return 0.06643724; case 19: return 0.06461716; case 20: return 0.06112521; case 21: return 0.05623791; case 22: return 0.05032389; case 23: return 0.04379813; case 24: return 0.03707432; case 25: return 0.03052299; case 26: return 0.0244409; case 27: return 0.01903459; case 28: return 0.01441804; case 29: return 0.01062197; case 30: return 0.00761097; case 31: return 0.0053041; case 32: return 0.00359517; case 33: return 0.00237008; case 34: return 0.00151965; case 35: return 0.00094768; default: return 0.0; } }vec4 directionalBlur(vec2 uv, bool isVertical) { vec4 color = vec4(0.0); vec2 pos = vec2(0.48586956521739133, 0.5295652173913044) + mix(vec2(0), (uMousePos-0.5), 0.0000);vec2 st = uv * rot(0.5000 * 2. * PI); pos *= rot(0.5000 * 2. * PI);float dist = easeInOutQuad(pos.y - st.y); float jawn = st.y < pos.y ? 1. : 0.;float amount = 0.9100 * 6. * dist * jawn;if (amount < 0.0001) { return texture(uTexture, uv); } color += texture(uTexture, uv) * 0.00094768;vec2 direction = isVertical ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0); for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; vec2 offset = vec2(x * 0.001) * direction; color += texture(uTexture, uv + offset) * getGaussianWeight(i); }float dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0; color.rgb += dither;return color; }vec4 getColor(vec2 uv) { return directionalBlur(uv, true); }void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}","#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution;out vec4 fragColor;const float PI = 3.141592;mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }float easeInOutQuad(float t) { return t < 0.5 ? 2.0 * t * t : -1.0 + (4.0 - 2.0 * t) * t; }const int kernelSize = 36; float getGaussianWeight(int index) { switch(index) { case 0: return 0.00094768; case 1: return 0.00151965; case 2: return 0.00237008; case 3: return 0.00359517; case 4: return 0.0053041; case 5: return 0.00761097; case 6: return 0.01062197; case 7: return 0.01441804; case 8: return 0.01903459; case 9: return 0.0244409; case 10: return 0.03052299; case 11: return 0.03707432; case 12: return 0.04379813; case 13: return 0.05032389; case 14: return 0.05623791; case 15: return 0.06112521; case 16: return 0.06461716; case 17: return 0.06643724; case 18: return 0.06643724; case 19: return 0.06461716; case 20: return 0.06112521; case 21: return 0.05623791; case 22: return 0.05032389; case 23: return 0.04379813; case 24: return 0.03707432; case 25: return 0.03052299; case 26: return 0.0244409; case 27: return 0.01903459; case 28: return 0.01441804; case 29: return 0.01062197; case 30: return 0.00761097; case 31: return 0.0053041; case 32: return 0.00359517; case 33: return 0.00237008; case 34: return 0.00151965; case 35: return 0.00094768; default: return 0.0; } }vec4 finalBlur(vec2 uv) { vec4 color = vec4(0.0); vec2 pos = vec2(0.48586956521739133, 0.5295652173913044) + mix(vec2(0), (uMousePos-0.5), 0.0000);vec2 st = uv * rot(0.5000 * 2. * PI); pos *= rot(0.5000 * 2. * PI);float dist = easeInOutQuad(pos.y - st.y); float jawn = st.y < pos.y ? 1. : 0.;float amount = 0.9100 * 11. * dist * jawn;if (amount < 0.0001) { return texture(uTexture, uv); } color += texture(uTexture, uv) * 0.00094768; for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; color += texture(uTexture, uv + vec2(x * 0.001, 0)) * getGaussianWeight(i) * 0.5; color += texture(uTexture, uv + vec2(0, x * 0.001) * vec2(1, uResolution.x/uResolution.y)) * getGaussianWeight(i) * 0.5; }return color; }vec4 getColor(vec2 uv) { return finalBlur(uv); }void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}","#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture; uniform vec2 uMousePos; uvec2 pcg2d(uvec2 v) { v = v * 1664525u + 1013904223u; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; v ^= v >> 16; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; return v; }float randFibo(vec2 p) { uvec2 v = floatBitsToUint(p); v = pcg2d(v); uint r = v.x ^ v.y; return float(r) / float(0xffffffffu); }out vec4 fragColor;const float PI = 3.141592;mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }float easeInOutQuad(float t) { return t < 0.5 ? 2.0 * t * t : -1.0 + (4.0 - 2.0 * t) * t; }const int kernelSize = 36;vec4 composite(vec2 uv) { vec4 bg = texture(uBgTexture, uv); vec4 fg = texture(uTexture, uv); float dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0; fg.rgb += dither;vec2 pos = vec2(0.48586956521739133, 0.5295652173913044) + mix(vec2(0), (uMousePos-0.5), 0.0000);vec2 st = uv * rot(0.5000 * 2. * PI); pos *= rot(0.5000 * 2. * PI);float dist = easeInOutQuad(pos.y - st.y); float jawn = st.y < pos.y ? 1. : 0.;float m = 0.9100 * 11. * dist * jawn; return mix(fg, bg, smoothstep(0., 1.0, 1. - m)); }vec4 getColor(vec2 uv) { return composite(uv); }void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"downSample":0.25,"depth":false,"uniforms":{},"isBackground":false,"passes":[{"prop":"pass","value":0,"downSample":0.25},{"prop":"pass","value":1,"downSample":0.5},{"prop":"pass","value":2,"downSample":0.5},{"prop":"pass","value":3,"includeBg":true}]},"id":"effect7"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"vignette","usesPingPong":false,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float; in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform vec2 uResolution;out vec4 fragColor; mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); } void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); float luma = dot(color.rgb, vec3(0.299, 0.587, 0.114)); float displacement = (luma - 0.5) * 0.0000 * 0.5; vec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1.0); vec2 skew = vec2(0.1600, 1.0 - 0.1600); float halfRadius = 0.6220 * 0.5; float innerEdge = halfRadius - 1.0000 * halfRadius * 0.5; float outerEdge = halfRadius + 1.0000 * halfRadius * 0.5; vec2 pos = vec2(0.4913043478260869, 0.7278260869565217); const float TWO_PI = 6.28318530718; vec2 scaledUV = uv * aspectRatio * rot(0.0027 * TWO_PI) * skew; vec2 scaledPos = pos * aspectRatio * rot(0.0027 * TWO_PI) * skew; float radius = distance(scaledUV, scaledPos); float falloff = smoothstep(innerEdge + displacement, outerEdge + displacement, radius); vec3 finalColor;finalColor = mix(color.rgb, mix(color.rgb, vec3(0, 0, 0), 1.0000), falloff); color = mix(color * (1.-falloff), vec4(finalColor * color.a, color.a), 1.0000); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect8"}],"options":{"name":"Copy of Reflect Blackhole (Remix)","fps":60,"dpi":1.5,"scale":1,"includeLogo":false,"isProduction":false,"freePlan":false},"version":"1.4.33","id":"ILgOO23w4wEyPQOKyLO4"}